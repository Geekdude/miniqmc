Distance tables are added to the particleset
Two options for this are:
createDistanceTable(const ParticleSet& s, ParticleSet& t, int dt_type) // for those with a source and a target, think electron-ion
and
createDistanceTable(const ParticleSet& s, int dt_type) // for a symmetric distance table.  Think electron-electron

Distance tables themselves inherit from DistanceTableData and DTD_BConds<T, D, SC>

DistanceTableData stores several elements
  -- Matrix<RealType> Distances  [Nsources] x [Ntargets]  (actual distance from source i to target j)
  -- vector<RowContainer> Displacements [Nsources] x [3][Ntargets] (displacement vector from source i to target j
  -- aligned_vector<RealType> Temp_r
  -- RowContainer Temp_dr
  -- also holds onto a pointer to the source particleSet called Origin
 It also has several virtual methods
  -- evaluate
       for Symmetric:
  inline void evaluate(ParticleSet& P)
  {
    constexpr T BigR = std::numeric_limits<T>::max();
    // P.RSoA.copyIn(P.R);
    for (int iat = 0; iat < Ntargets; ++iat)
    {
      DTD_BConds<T, D, SC>::computeDistances(P.R[iat],
                                             P.RSoA,
                                             Distances[iat],
                                             Displacements[iat],
                                             0,
                                             Ntargets,
                                             iat);
      Distances[iat][iat] = BigR; // assign big distance
    }
  }
  and
  inline void evaluate(ParticleSet& P, IndexType jat)
  {
    DTD_BConds<T, D, SC>::computeDistances(P.R[jat],
                                           P.RSoA,
                                           Distances[jat],
                                           Displacements[jat],
                                           0,
                                           Ntargets,
                                           jat);
    Distances[jat][jat] = std::numeric_limits<T>::max(); // assign a big number
  }

       for Asymmetric:
  inline void evaluate(ParticleSet& P)
  {
    // be aware of the sign of Displacement
    for (int iat = 0; iat < Ntargets; ++iat)
      DTD_BConds<T, D, SC>::computeDistances(P.R[iat],
                                             Origin->RSoA,
                                             Distances[iat],
                                             Displacements[iat],
                                             0,
                                             Nsources);
  }
  and
  inline void evaluate(ParticleSet& P, IndexType iat)
  {
     DTD_BConds<T, D, SC>::computeDistances(P.R[iat],
                                            Origin->RSoA,
                                            Distances[iat],
                                            Displacements[iat],
                                            0,
                                            Nsources);
  }
 


  -- move (evaluate temporatry pair relations)
      For Symmetric:
  inline void move(const ParticleSet& P, const PosType& rnew)
  {
    moveOnSphere(P, rnew);
  }
      For Asymmetric:
    /// evaluate the temporary pair relations
  inline void move(const ParticleSet& P, const PosType& rnew)
  {
    DTD_BConds<T, D, SC>::computeDistances(rnew, Origin->RSoA, Temp_r.data(), Temp_dr, 0, Nsources);
  }

  -- moveOnSphere (evaluate distance tables with a sphere move)
      For Symmetric:
  inline void moveOnSphere(const ParticleSet& P, const PosType& rnew)
  {
    DTD_BConds<T, D, SC>::computeDistances(rnew, P.RSoA, Temp_r.data(), Temp_dr, 0, Ntargets, P.activePtcl);
  }
      For Asymmetric:
  inline void moveOnSphere(const ParticleSet& P, const PosType& rnew)
  {
    DTD_BConds<T, D, SC>::computeDistances(rnew, Origin->RSoA, Temp_r.data(), Temp_dr, 0, Nsources);
  }

  -- update (upate the distance table by the pair relations)
      For Symmetric:
  inline void update(IndexType iat)
  {
    if (iat == 0)
      return;
    // update by a cache line
    const int nupdate = getAlignedSize<T>(iat);
    simd::copy_n(Temp_r.data(), nupdate, Distances[iat]);
    for (int idim = 0; idim < D; ++idim)
      simd::copy_n(Temp_dr.data(idim), nupdate, Displacements[iat].data(idim));
  }
      For Asymmetric:
  inline void update(IndexType iat)
  {
    simd::copy_n(Temp_r.data(), Nsources, Distances[iat]);
    for (int idim = 0; idim < D; ++idim)
      simd::copy_n(Temp_dr.data(idim), Nsources, Displacements[iat].data(idim));
  }


Now for DTD_BConds<T, D, SC>
  -- First on the template parameters.   
      --T is the real type (float or double)   
      --D is the number of dimensions (3 in our case)
      --SC is the supercell type ( encodes pbc or obc in each direction and SoA or not)
  -- For the case of the miniapp we care about a 3D case SoA layout, periodic in all directions and of a general type of lattice (not specialized to orthorhombic)

DTD_Bconds stores several elements (mostly related to the lattice):
  -- g00, g10, g20, g01, g11, g21, g02, g12, g22
  -- r00, r10, r20, r01, r11, r21, r02, r12, r22
  -- VectorSoAContainer<T, 3> corners

  -- Then it provides a single computeDistances method which updates temp_r and temp_dr
     for all particles from index first to index last from position pos
  template<typename PT, typename RSoA>
  void computeDistances(const PT& pos,
                        const RSoA& R0,
                        T* restrict temp_r,
                        RSoA& temp_dr,
                        int first,
                        int last,
                        int flip_ind = 0)
  {
    const T x0 = pos[0];
    const T y0 = pos[1];
    const T z0 = pos[2];

    const T* restrict px = R0.data(0);
    const T* restrict py = R0.data(1);
    const T* restrict pz = R0.data(2);

    T* restrict dx = temp_dr.data(0);
    T* restrict dy = temp_dr.data(1);
    T* restrict dz = temp_dr.data(2);

    const T* restrict cellx = corners.data(0);
    ASSUME_ALIGNED(cellx);
    const T* restrict celly = corners.data(1);
    ASSUME_ALIGNED(celly);
    const T* restrict cellz = corners.data(2);
    ASSUME_ALIGNED(cellz);

    constexpr T minusone(-1);
    constexpr T one(1);
    #pragma omp simd aligned(temp_r, px, py, pz, dx, dy, dz)
    for (int iat = first; iat < last; ++iat)
    {
      const T flip    = iat < flip_ind ? one : minusone;
      const T displ_0 = (px[iat] - x0) * flip;
      const T displ_1 = (py[iat] - y0) * flip;
      const T displ_2 = (pz[iat] - z0) * flip;

      const T ar_0 = -std::floor(displ_0 * g00 + displ_1 * g10 + displ_2 * g20);
      const T ar_1 = -std::floor(displ_0 * g01 + displ_1 * g11 + displ_2 * g21);
      const T ar_2 = -std::floor(displ_0 * g02 + displ_1 * g12 + displ_2 * g22);

      const T delx = displ_0 + ar_0 * r00 + ar_1 * r10 + ar_2 * r20;
      const T dely = displ_1 + ar_0 * r01 + ar_1 * r11 + ar_2 * r21;
      const T delz = displ_2 + ar_0 * r02 + ar_1 * r12 + ar_2 * r22;

      T rmin = delx * delx + dely * dely + delz * delz;
      int ic = 0;
#pragma unroll(7)
      for (int c = 1; c < 8; ++c)
      {
        const T x  = delx + cellx[c];
        const T y  = dely + celly[c];
        const T z  = delz + cellz[c];
        const T r2 = x * x + y * y + z * z;
        ic         = (r2 < rmin) ? c : ic;
        rmin       = (r2 < rmin) ? r2 : rmin;
      }

      temp_r[iat] = std::sqrt(rmin);
      dx[iat]     = flip * (delx + cellx[ic]);
      dy[iat]     = flip * (dely + celly[ic]);
      dz[iat]     = flip * (delz + cellz[ic]);
    }
  }
};






  -- also has 
        inline T apply_bc(TinyVector<T, D>& displ) const { return dot(displ, displ); }
        inline void apply_bc(std::vector<TinyVector<T, D>>& dr, std::vector<T>& r, std::vector<T>& rinv) const
        {
          const int n = dr.size();
          const T cone(1);
          for (int i = 0; i < n; ++i)
          {
            r[i]    = std::sqrt(apply_bc(dr[i]));
            rinv[i] = cone / r[i];
          }
        }


-- The distance tables